### 1、React优势

react适合大型团队的开发，每个人负责自己的组件，开发完毕之后由react渲染到前端页面

### 2、什么是JSX

JavaScript与XML的结合，方便用html代码创建虚拟DOM，虚拟DOM不是真实的DOM节点，而是虚拟化的，他可以快速反应，不占用页面的渲染机制，而且快速反应我们的动作。

在JSX中

* 当它遇到`<`就会把代码当做HTML语法来解析
* 当它遇到`{`就会把代码当做JavaScript来解析

```jsx
//渲染到哪里
ReactDOM.render(<App />, document.getElementById("root"))
```

使用Fragment可以将最外层标签实现取消的效果

```jsx
// import React, {Component} from 'react'
import React, {Component, Fragment} from 'react'

class Xiaojiejie extends Component {
    render() {
        return (
            // <div>
            <Fragment>
                <div>
                    <input/>
                    <button>增加服务</button>
                    <ul>
                        <li>头部按摩</li>
                        <li>精油推背</li>
                    </ul>
                </div>
                {/*</div>*/}
            </Fragment>
        )
    }
}

export default Xiaojiejie
```

### 3、什么是响应式设计？

React以数据为驱动，不进行（官方也不建议）DOM操作，只需要关心数据就好了。

增加数据怎么增加？

在构造函数中实现。

```jsx
return{
  // ........................
  
{/* 下面用this.state.inputValue = e.target.value会报错，需要进行绑定 */}
<input value={this.state.inputValue} onChange={this.inputChange.bind(this)}/>
    // ........................
    )
}
    inputChange(e) {
        // 但是通过这种方式，在页面上看不到数据有任何的变化
        console.log(this)
        // 下面会报错，this的指向是错误的，需要使用bind方法进行绑定才可以
        // this.state.inputValue = e.target.value
        // 同时数据的改变也不能用上面这种方式
      
        this.setState({
            inputValue: e.target.value
        })
    }
```

### 4、父组件向子组件传值

就相当于增加服务这个功能，就是父组件向子组件传递参数。

首先创建一个js文件，命名为`XiaojiejieItem`，这是`Xiaojiejie`的子组件

```jsx
import React, {Component} from "react";
import "./style.css";
// import Xiaojiejie from "./Xiaojiejie";

class XiaojiejieItem extends Component {
    // state = {}
    render() {
        return (
            <li>
                {/*这种方式是写死的，不能实现参数传递*/}
                小姐姐
            </li>
        );
    }
}

export default XiaojiejieItem
```

然后在父组件中，设置属性的key值，可以自定义命名，这里命名为`content`。

```jsx
								<ul>
									  {
                        this.state.list.map((item, index) => {
                            return (
                                <
                                    XiaojiejieItem
                                    key={item + index}
                                    content={item}
                                />
                            )
                        })
                    }
                </ul>
```

设置好之后，子组件通过`this.props.key`来接收传递过来的值，也就是`content`。

```jsx
            <li>
            		{/* 通过this.props接收子组件传递过来的值 */}
                {this.props.content}
            </li>
```

this.props能接收所有的属性和方法。

### 5、子组件向父组件传值

react中，不允许子组件向父组件直接传值。

可以通过下面这种绑定的形式来传值。

```jsx
    render() {
        return (
            <li onClick={this.handleClick.bind(this)}>
                {/*这种方式是写死的，不能实现参数传递*/}
                {/*小姐姐*/}
                {this.props.content}
            </li>
        );
    }

    handleClick() {
        console.log(this.props.index)
    }
```

还有种方式是通过构造函数的方式，通过这种方式，对以后的性能优化会起到很好的作用。

```jsx
    constructor(props) {
        super(props);
        this.handleClick = this.handleClick.bind(this)
    }
```

#### 5.1 子组件不能直接改变父组件的值

删除。就是我们的demo中，通过点击数据，删除父组件中的数据。